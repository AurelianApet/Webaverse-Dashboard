<!doctype html>
<html>
  <head>
    <link rel="dns-prefetch" href="https://render.exokit.xyz">
    <link rel=icon type="image/png" href="favicon.png">
    <meta name="twitter:image:src" content="https://browser.exokit.org/logo.svg">
    <meta name="twitter:site" content="@exokitxr">
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Exokit Browser">
    <meta name="twitter:description" content="WebXR VR/AR meta-browser. Construct your reality out of 3D web sites.">
    <meta property="og:title" content="Exokit Browser">
    <meta property="og:type" content="referenceSpace">
    <meta property="og:url" content="https://browser.exokit.org/">
    <meta property="og:image" content="https://browser.exokit.org/logo.svg">
    <meta http-equiv="origin-trial" content="AspvaSU7F1Gbpa8q9JRNRNXFF+0+77C1xkxf1hkzJCrBI7Mmt/eG25QXLBn7lfzPsgrN5next8ZtIiCeGs6R4w8AAABleyJvcmlnaW4iOiJodHRwczovL2V4b2tpdC5vcmc6NDQzIiwiZmVhdHVyZSI6IldlYlhSRGV2aWNlTTc2IiwiZXhwaXJ5IjoxNTcxMTEyNjU0LCJpc1N1YmRvbWFpbiI6dHJ1ZX0=">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600,700&display=swap" rel="stylesheet">
    <script src="https://kit.fontawesome.com/0735724151.js" crossorigin="anonymous"></script>
    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="BufferGeometryUtils.js"></script>
    <style>
* {
  box-sizing: border-box;
}
body {
  width: 100vw;
  height: 100vh;
  margin: 0;
  font-family: 'Open Sans';
  font-size: 12px;
  overflow: hidden;
}
a {
  cursor: pointer;
}
ul {
  margin: 0;
  padding: 0;
  list-style-type: none;
}
header {
  position: absolute;
  display: flex;
  top: 0;
  left: 0;
  width: 100vw;
  height: 50px;
  background-color: #FFF;
  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.08);
  align-items: center;
  user-select: none;
  z-index: 1;
}
header .icon {
  height: 25px;
  margin: 0 10px;
}
header .nav {
  display: flex;
  height: 100%;
  padding: 0 10px;
  justify-content: center;
  align-items: center;
  border-top: 3px solid transparent;
  border-bottom: 3px solid transparent;
  color: inherit;
  font-size: 14px;
  text-decoration: none;
  text-transform: uppercase;
}
header .nav:hover, header .nav.open {
  border-bottom-color: #ef5350;
}
header .nav i {
  display: inline-block;
  padding: 0 7px;
  padding-top: 2px;
}
input[type=email],
input[type=text]
{
  margin-right: 10px;
  padding: 7px 15px;
  background-color: #f2f3f5;
  border: 0;
  border-radius: 8px;
  font-family: inherit;
  font-size: inherit;
  outline: none;
}
header > .login-form {
  display: flex;
  margin-left: auto;
}
body.logging-in .login-form,
header > .login-form:not(.phase-1) > .phase-1-content,
header > .login-form:not(.phase-2) > .phase-2-content,
header > .login-form:not(.phase-3) > .phase-3-content,
header > .login-form.phase-1 > .phaseless-content,
header > .login-form.phase-2 > .phaseless-content,
header > .login-form.phase-3 > .phaseless-content
{
  display: none;
}
.tools, .colors {
  display: flex;
  position: absolute;
  z-index: 1;
}
.tools {
  top: 60px;
  left: 10px;
}
.tools > .tool, .colors > .color {
  display: flex;
  width: 30px;
  height: 30px;
  justify-content: center;
  align-items: center;
  font-size: 16px;
  /* color: #000; */
  cursor: pointer;
}
.tools > .tool {
  background-color: #EEE;
}
.tools > .tool:hover {
  background-color: #42a5f5;
  color: #FFF;
}
.tools > .tool:active, .tools > .tool.selected {
  background-color: #1e88e5;
  color: #FFF;
}
.colors {
  bottom: 10px;
  left: 10px;
}
.colors > .color {
  position: relative;
}
.colors > .color > .inner {
  position: absolute;
  top: 3px;
  bottom: 3px;
  left: 3px;
  right: 3px;
}
.colors > .color:hover {
  background-color: #333;
}
.colors > .color:active, .colors > .color.selected {
  background-color: #000;
}
.button {
  display: inline-block;
  margin-right: 15px;
  padding: 7px 15px;
  border: 0;
  border-radius: 8px;
  color: #FFF;
  text-decoration: none;
  cursor: pointer;
  outline: none;
}
.button.highlight {
  background-color: #ef5350;
}
.button.highlight:hover {
  background-color: #d32f2f;
}
.login-form .phase-content {
  display: flex;
  align-items: center;
}
.login-form .phase-content .login-error
{
  margin-right: 15px;
  font-weight: 600;
}
.login-form .phase-content .user-button {
  display: flex;
  height: 30px;
  margin-right: 10px;
  padding: 3px 10px;
  background-color: #f2f3f5;
  border-radius: 8px;
  align-items: center;
  cursor: pointer;
}
.login-form .phase-content .user-button:hover,
.login-form .phase-content .user-button.open {
  background-color: #CCC;
}
.login-form .phase-content .user-button > img {
  width: 20px;
  height: 20px;
  margin-right: 5px;
}
.login-form .phase-content .user-button > .name {
  display: flex;
  height: 100%;
  font-weight: 600;
  align-items: center;
}
.login-form .phase-content .login-notice {
  color: #4caf50;
}
.login-form .phase-content .login-error {
  color: #e53935;
}
.login-form .phaseless-content {
  padding: 0 30px;
}
.user-account {
  position: absolute;
  top: 50px;
  display: flex;
  width: 100%;
  height: 300px;
  padding: 0 72px;
  background-color: #FFF;
  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.08);
  flex-direction: column;
  z-index: 1;
}
.user-account:not(.open) {
  display: none;
}
.user-account .wrap {
  width: 400px;
}
.user-account h1 {
  margin: 0;
  margin-bottom: 10px;
}
.user-account .row {
  display: flex;
  margin: 5px 0;
  align-items: center;
}
.user-account .text {
  margin-right: 5px;
}
.user-account .status {
  display: flex;
  padding: 3px 6px;
  border-radius: 8px;
  color: #FFF;
  align-items: center;
}
.user-account .status:not(.open) {
  display: none;
}
.user-account .status.not-connected {
  background-color: #5c6bc0;
}
.user-account .status.connected {
  background-color: #66bb6a;
}
.user-account .status nav {
  display: flex;
  width: 16px;
  height: 16px;
  margin-left: 5px;
  /* background-color: #ef534e; */
  justify-content: center;
  align-items: center;
  cursor: pointer;
}
.user-account .status i {}
.user-account .connect-stripe-button:not(.visible) {
  display: none;
}
.user-account input[type=text] {
  width: 300px;
  padding: 10px;
  background-color: #f2f3f5;
  border: 0;
  border-radius: 8px;
}
.user-account input[type=button] {
  display: flex;
  margin-left: auto;
  padding: 10px;
  background-color: #ef5350;
  border: 0;
  border-radius: 8px;
  color: #FFF;
  cursor: pointer;
  outline: none;
}
.user-account input[type=button]:hover {
  background-color: #d32f2f;
}
.multibutton {
  position: absolute;
  right: 30px;
  bottom: 30px;
  display: flex;
}
.multibutton > .button {
  margin-right: 5px;
}
.multibutton > .button {
  display: inline-flex;
  padding: 8px 20px;
  border: 2px solid;
  border-radius: 100px;
  color: #5c6bc0;
  cursor: pointer;
}
.multibutton > .button:not(.first) {
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;
}
.multibutton > .button:not(.last) {
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;
}
.multibutton  .button:not([disabled]):hover {
  background-color: #5c6bc0;
  border-color: #5c6bc0;
  color: #FFF;
}
.multibutton .button[disabled] {
  color: #b71c1c;
  cursor: auto;
}
header .popup {
  position: absolute;
  display: flex;
  flex-direction: column;
  top: 60px;
  right: 20px;
  width: 500px;
  padding: 20px;
  background-color: #444;
  border: 2px solid rgba(0,0,0,0.5);
  color: #FFF;

  display: none;
}
header .popup::before {
  position: absolute;
  top: -20px;
  right: 150px;
  border-width: 0 0 20px 20px;
  border-style: solid;
  border-color: transparent;
  border-bottom-color: #444;
  content: ''
}
header .close {
  position: absolute;
  top: 20px;
  right: 20px;
  font-size: 20px;
  color: #FFF;
  text-decoration: none;
}
header .popup h1 {
  display: flex;
  flex-direction: column;
  margin: 0;
  font-size: 50px;
  line-height: 55px;
  font-weight: 600;
  color: rgba(255,255,255,1);
}
header .popup strong {
  font-size: 14px;
  line-height: 1.1;
  color: #ef5350;
  text-transform: uppercase;
}
header .popup p {
  margin-top: 20px;
  margin-bottom: 40px;
  font-size: 20px;
  line-height: 30px;
  color: rgba(255,255,255,0.5);
}
header .popdown {
  flex-direction: column;
  padding: 10px;
  /* border: 2px solid rgba(0,0,0,0.5); */
  color: #FFF;
}
body:not(.logged-in) #enter-buttons
{
  display: none;
}
#login-blocker {
  display: none;
}
body:not(.logging-in):not(.logged-in) #login-blocker {
  display: flex;
}
.blocker {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: rgba(0, 0, 0, 0.5);
  user-select: none;
}
.blocker .wrap {
  width: 300px;
  padding: 50px;
  background-color: #FFF;
  border-radius: 8px;
  text-align: center;
}
/* .blocker .wrap i {
  position: absolute;
  top: 0;
  right: 0;
} */
.blocker .wrap img {
  width: 100px;
  height: 100px;
}
.blocker .wrap h1, .blocker .wrap h2, .blocker .wrap h3 {
  margin: 0;
  /* font-weight: 300; */
}
.blocker .wrap .button {
  margin: 10px 0;
}
.blocker a {
  color: #42a5f5;
  text-decoration: none;
}
.blocker a:hover {
  color: #1e88e5;
}
#controls-popdown {
  position: absolute;
  top: 50px;
  left: 0;
  width: 35vw;
  padding: 15px;
  background-color: #FFF;
  box-shadow: 0 2px 4px 0 rgba(0, 0, 0, 0.08);
  color: black;
  font-size: 12px;
  border-top: 2px solid #000;
}
#subscribe-popdown {
  position: absolute;
  top: 50px;
  left: 0;
  width: 100vw;
  padding: 30px;
  background-color: rgba(33,33,33,1);
  border-top: 2px solid #141414;
}
#subscribe-popdown .plans {
  display: flex;
  margin-bottom: 20px;
}
#subscribe-popdown .plans .plan {
  display: flex;
  width: 180px;
  padding: 30px;
  margin: 10px;
  flex-direction: column;
  border: 2px solid;
  border-radius: 10px;
  color: #444;
  cursor: pointer;
  align-items: center;
}
#subscribe-popdown .plans .plan:hover {
  color: #666;
}
#subscribe-popdown .plans .plan.selected {
  color: #5c6bc0;
}
#subscribe-popdown .plans .plan i {
  margin-bottom: 10px;
  font-size: 70px;
}
#subscribe-popdown .plans .plan .wrap {
  display: flex;
  flex-direction: column;
}
/* #subscribe-popdown .plans h3 {
  margin: 0;
  font-size: 30px;
}
#subscribe-popdown .plans strong {
  margin-bottom: 10px;
  text-transform: uppercase;
}
#subscribe-popdown .plans p {
  margin: 0;
  line-height: 1.4;
} */
#developers-popdown {
  position: absolute;
  display: flex;
  top: 50px;
  left: 380px;
  width: 300px;
  background-color: #444;
}
header .popdown:not(.open) {
  display: none !important;
}
header .popdown ul {
  font-size: 14px;
  line-height: 2;
}
header .popdown li {
  margin: 10px 0;
}
canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100vh;
  background-color: #000;
}
table {
  width: 100%;
}
table colgroup col:nth-child(1) {
  width: 20%;
}
table colgroup col:nth-child(3) {
  width: 60%;
}
table tr {
  background-color: #f2f3f5;
}
    </style>
  </head>
  <body >
    <header id=header>
      <a href="https://browser.exokit.org">
        <img class=icon src="logo.svg"/>
      </a>
      <a href="/" class="nav" id="explore-dropdown">Exobrowser</a>
      <a class="nav" id="controls-dropdown">Controls</a>
      <div class="popdown" id="controls-popdown">
        <table>
          <colgroup>
            <col>
            <col>
            <col>
          </colgroup>  
          <tbody>
          <tr>
            <td>KEY/BUTTON</td>
            <td>ACTION</td>
            <td>DESCRIPTION</td>
          </tr>
          <tr>
            <td><b>Enter XR</b></td>
            <td>XR Mode</td>
            <td>If you are using a headset or have one plugged in, you can view through your headset.</td>
          </tr>
          <tr>
            <td><b>Enter 2D</b></td>
            <td>2D Mode</td>
            <td>Emulate an XR device with keyboard/mouse. Alternatively, double click to enter 2D.</td>
          </tr>
          <tr>
            <td><b>LMB</b></td>
            <td>Gamepad trigger</td>
            <td>Click the right gamepad's trigger.</td>
          </tr>
          <tr>
            <td><b>MMB</b></td>
            <td>Gamepad touch</td>
            <td>Press the right gamepad's touchpad/thumb stick.</td>
          </tr>
          <tr>
            <td><b>Tab</b></td>
            <td>Toggle edit</td>
            <td>Toggle edit mode which lets you add, move, and delete apps from your scene.</td>
          </tr>
          <tr>
            <td><b>DEL</b></td>
            <td>Delete app</td>
            <td>Delete the currently selected opened app.</td>
          </tr>
          <tr>
            <td><b>ESC</b></td>
            <td>Exit 2D</td>
            <td>This is useful if you want to type with your keyboard.</td>
          </tr>
          </tbody>
        </table>
      </div>
      <!-- <a class="nav" id="explore-dropdown">Explore</a>
      <a class="nav">Download</a>
      <a class="nav" id="developers-dropdown">Developers<i class="fal fa-chevron-down"></i></a> -->
      <form class="login-form phase-1" id=login-form>
        <div class=phase-content>
          <div class=login-notice id=login-notice></div>
          <div class=login-error id=login-error></div>
        </div>
        <div class="phase-content phase-1-content">
          <input type=email placeholder="your@email.com" id=login-email>
          <input type=submit value="Log in" class="button highlight">
        </div>
        <div class="phase-content phase-2-content">
          <input type=text placeholder="Verification code" id=login-verification-code>
          <input type=submit value="Verify" class="button highlight">
        </div>
        <div class="phase-content phase-3-content">
          <nav class=user-button id=user-button>
            <img src="exobot.png">
            <span class=name id=login-email-static>a@modules.io</span>
          </nav>
          <input type=submit value="Log out" class="button highlight">
        </div>
        <div class="phase-content phaseless-content">
          <div>Working...</div>
        </div>
      </form>
      <div class=user-account id=user-account>
        <div class=wrap>
          <h1 id=login-name-static></h1>
          <div class=row>
            <input type=text placeholder="Enter WebXR URL" id=site-url-bar>
            <input type=button value="Submit Site" id=submit-site>
          </div>
          <div class=row>
            <div class=text>Stripe Connect status:</div>
            <div class="status not-connected" id=status-not-connected>Not connected</div>
            <div class="status connected" id=status-connected>Connected <nav id=disconnect-stripe-button><i class="fal fa-times"></i></nav></div>
            <input type=button value="Connect Stripe" class=connect-stripe-button id=connect-stripe-button>
          </div>
        </div>
      </div>
      <!-- <div class="popdown" id="developers-popdown">
        <ul>
          <li>CLI</li>
          <li>SDK</li>
        </ul>
      </div> -->
    </header>

    <div class=tools>
      <nav class="tool selected"><i class="fal fa-mouse-pointer"></i></nav>
      <nav class=tool><i class="fal fa-brush"></i></nav>
    </div>
    <div class=colors>
      <nav class="color selected"><div class=inner style="background-color: #ef5350;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #ec407a;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #ab47bc;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #7e57c2;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #5c6bc0;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #42a5f5;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #29b6f6;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #26c6da;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #26a69a;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #66bb6a;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #9ccc65;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #d4e157;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #ffee58;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #ffca28;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #ffa726;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #ff7043;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #8d6e63;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #bdbdbd;"></div></nav>
      <nav class="color"><div class=inner style="background-color: #78909c;"></div></nav>
    </div>

    <canvas id=canvas></canvas>

    <!-- <script src="https://kit.fontawesome.com/0735724151.js"></script> -->
<script>
const PARCEL_SIZE = 10;

const canvas = document.getElementById('canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const renderer = new THREE.WebGLRenderer({
  canvas,
  antialias: true,
});
renderer.setPixelRatio(window.devicePixelRatio);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0xCCCCCC);
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 3;
renderer.render(scene, camera);

const ambientLight = new THREE.AmbientLight(0x808080);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xFFFFFF, 1);
directionalLight.position.set(0.5, 1, 0.5);
scene.add(directionalLight);

const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
// orbitControls.target.copy(camera.position).add(new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion));
orbitControls.screenSpacePanning = true;
// orbitControls.enabled = !!loginToken;
orbitControls.enableMiddleZoom = false;
orbitControls.update();

const pointerMesh = (() => {
  const targetGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, -0.1, 0)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0, 0, 0.1)),
    new THREE.BoxBufferGeometry(0.03, 0.2, 0.03)
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, -1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.1, 0, 0)),
  ]);
  const sidesGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries([
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, 0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, 0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(-0.5, -0.5, 0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 1, 0), new THREE.Vector3(1, 0, 0))))
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, -1, 0))))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, -0.5)),
    targetGeometry.clone()
      .applyMatrix(new THREE.Matrix4().makeRotationFromQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(-1, 1, 0).normalize(), new THREE.Vector3(1, -1, 0).normalize())))
      .applyMatrix(new THREE.Matrix4().makeTranslation(0.5, -0.5, 0.5)),
  ]);
  const sidesColors = new Float32Array(sidesGeometry.attributes.position.array.length);
  // sidesColors.fill(0);
  sidesGeometry.setAttribute('color', new THREE.BufferAttribute(sidesColors, 3));
  // const numSidesPositions = sidesGeometry.attributes.position.array.length;
  const dotsGeometries = [];
  const dotGeometry = new THREE.BoxBufferGeometry(0.01, 0.01, 0.01);
  for (let x = 0; x < 10; x++) {
    for (let y = 0; y < 10; y++) {
      for (let z = 0; z < 10; z++) {
        const newDotGeometry = dotGeometry.clone()
          .applyMatrix(new THREE.Matrix4().makeTranslation(x*0.1 - 0.5, y*0.1 - 0.5, z*0.1 - 0.5));
        dotsGeometries.push(newDotGeometry);
      }
    }
  }
  const dotsGeometry = THREE.BufferGeometryUtils.mergeBufferGeometries(dotsGeometries);
  const dotsColors = new Float32Array(dotsGeometry.attributes.position.array.length);
  dotsColors.fill(0.7);
  dotsGeometry.setAttribute('color', new THREE.BufferAttribute(dotsColors, 3));
  // const numDotsPositions = dotsGeometry.attributes.position.array.length;
  const geometry = THREE.BufferGeometryUtils.mergeBufferGeometries([sidesGeometry, dotsGeometry]);
  const targetVsh = `
    uniform vec3 targetPos;
    attribute vec3 color;
    varying vec2 vUv;
    varying vec3 vColor;
    varying float highlightColor;
    float scale = 0.1;
    void main() {
      vec4 p = modelMatrix * vec4(position, 1.);
      gl_Position = projectionMatrix * viewMatrix * p;
      vColor = color;
      vec3 tp = targetPos.xyz*scale - 0.5;
      if (p.x-0.1/2.0 >= tp.x && p.y-0.1/2.0 >= tp.y && p.z-0.1/2.0 >= tp.z &&
          p.x-0.1/2.0 < (tp.x + scale) && p.y-0.1/2.0 < (tp.y + scale) && p.z-0.1/2.0 < (tp.z + scale)) {
        highlightColor = 1.0;
      } else {
        highlightColor = 0.0;
      }
    }
  `;
  const targetFsh = `
    // uniform float uTime;
    varying vec3 vColor;
    varying float highlightColor;
    void main() {
      if (highlightColor > 0.0) {
        gl_FragColor = vec4(highlightColor, 0.0, 0.0, 1.0);
      } else {
        gl_FragColor = vec4(vColor, 1.0);
      }
    }
  `;
  const material = new THREE.ShaderMaterial({
    uniforms: {
      targetPos: {
        type: 'v3',
        value: new THREE.Vector3(),
      },
      uTime: {
        type: 'f',
        value: 0,
      },
    },
    vertexShader: targetVsh,
    fragmentShader: targetFsh,
    // transparent: true,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  // mesh.visible = false;
  return mesh;
})();
scene.add(pointerMesh);

const worker = (() => {
  let cbs = [];
  const worker = new Worker('mc-worker.js');
  worker.onmessage = e => {
    const {data} = e;
    const {error, result} = data;
    cbs.shift()(error, result);
  };
  worker.onerror = err => {
    console.warn(err);
  };
  worker.request = (req, transfers) => new Promise((accept, reject) => {
    worker.postMessage(req, transfers);

    cbs.push((err, result) => {
      if (!err) {
        accept(result);
      } else {
        reject(err);
      }
    });
  });
  return worker;
})();
const _makeMiningMesh = (x, z/*, token*/) => {
  const terrainVsh = `
    attribute vec3 color;
    varying vec3 vColor;
    varying vec3 vViewPosition;
    void main() {
      vec4 mvPosition = modelMatrix * vec4( position.xyz, 1.0 );
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position.xyz, 1.0 );
      vColor = color;
      vViewPosition = mvPosition.xyz;
    }
  `;
  const terrainFsh = `
    varying vec3 vColor;
    uniform vec3 uSelect;
    varying vec3 vViewPosition;
    // vec4 color = vec4(${new THREE.Color(0x9ccc65).toArray().map(n => n.toFixed(8)).join(',')}, 1.0);
    // vec4 color2 = vec4(${new THREE.Color(0xec407a).toArray().map(n => n.toFixed(8)).join(',')}, 1.0);
    bool inRange(vec3 pos, vec3 minPos, vec3 maxPos) {
      return pos.x >= minPos.x &&
        pos.y >= minPos.y &&
        pos.z >= minPos.z &&
        pos.x <= maxPos.x &&
        pos.y <= maxPos.y &&
        pos.z <= maxPos.z;
    }
    void main() {
      // vec3 vColor = vec3(1.0, 0, 0);
      vec4 color = vec4(vColor, 1.0);
      vec3 fdx = vec3( dFdx( -vViewPosition.x ), dFdx( -vViewPosition.y ), dFdx( -vViewPosition.z ) );
      vec3 fdy = vec3( dFdy( -vViewPosition.x ), dFdy( -vViewPosition.y ), dFdy( -vViewPosition.z ) );
      vec3 normal = normalize( cross( fdx, fdy ) );
      float dotNL = saturate( dot( normal, normalize(vec3(1.0, 1.0, 1.0))) );

      float range = 1.01;
      // float range = 2.01;
      vec3 minPos = uSelect - range;
      vec3 maxPos = minPos + (range*2.);
      /* if (inRange(vViewPosition, minPos, maxPos)) {
        gl_FragColor = color2;
      } else { */
        gl_FragColor = color;
      // }
      // gl_FragColor.rgb += dotNL * 0.5;
    }
  `;

  const geometry = new THREE.BufferGeometry();
  /* const material = new THREE.ShaderMaterial({
    uniforms: {
      uSelect: {
        type: 'v3',
        value: new THREE.Vector3(NaN, NaN, NaN),
      },
    },
    vertexShader: terrainVsh,
    fragmentShader: terrainFsh,
    extensions: {
      derivatives: true,
    },
  }); */
  const material = new THREE.MeshPhongMaterial({
    color: 0xFFFFFF,
    vertexColors: THREE.VertexColors,
  });
  const mesh = new THREE.Mesh(geometry, material);
  mesh.frustumCulled = false;
  mesh.visible = false;
  // mesh.token = token;

  const size = PARCEL_SIZE;
  const dims = Float32Array.from([size, size, size]);
  const potential = new Float32Array(size*size*size);
  potential.fill(1);
  /* for (let x = 0; x < size; x++) {
    for (let y = 0; y < size; y++) {
      for (let z = 0; z < size; z++) {
        if (
          x === 0 || y === 0 || z === 0 ||
          x === (size-1) || y === (size-1) || z === (size-1)
        ) {
          potential[x + y*size + z*size*size] = 0;
        }
      }
    }
  } */
  const brush = new Uint8Array(size*size*size*3);
  const shift = Float32Array.from([(x-0.5)*PARCEL_SIZE, (x-0.5)*PARCEL_SIZE, (z-0.5)*PARCEL_SIZE]);
  const scale = Float32Array.from([0.1, 0.1, 0.1]);

  mesh.x = x;
  mesh.z = z;
  mesh.potential = potential;
  mesh.brush = brush;
  mesh.shift = shift;
  mesh.scale = scale;
  mesh.contains = pos =>
    pos.x >= shift[0] &&
    pos.y >= shift[1] &&
    pos.z >= shift[2] &&
    pos.x < shift[0] + size &&
    pos.y < shift[1] + size &&
    pos.z < shift[2] + size;
  mesh.getPotential = pos => {
    const x = pos.x - shift[0];
    const y = pos.y - shift[1];
    const z = pos.z - shift[2];
    return potential[x + y*size*size + z*size];
  };
  mesh.paint = (x, y, z) => {
    // const x = Math.floor(pos.x - shift[0]);
    // const y = Math.floor(pos.y - shift[1]);
    // const z = Math.floor(pos.z - shift[2]);
    console.log('paint', x, y, z, currentColor);
    if (x >= 0 && x < PARCEL_SIZE && y >= 0 && y < PARCEL_SIZE && z >= 0 && z < PARCEL_SIZE) {
      const index = x + y*size*size + z*size;
      potential[index] = -1;
      /* const factor = 1;
      const max = Math.sqrt(factor*factor*3);
      for (let dx = -factor; dx <= factor; dx++) {
        for (let dz = -factor; dz <= factor; dz++) {
          for (let dy = -factor; dy <= factor; dy++) {
            const ax = x + dx;
            const ay = y + dy;
            const az = z + dz;
            if (
              ax >= 0 &&
              ay >= 0 &&
              az >= 0 &&
              ax < size &&
              ay < size &&
              az < size
            ) {
              const index = ax + ay*size*size + az*size;
              const d = (max - Math.sqrt(dx*dx + dy*dy + dz*dz)) / max * 2;
              potential[index] = Math.max(potential[index] - d, 0);
            }
          }
        }
      } */
      // if (brush[index*3] === 0 && brush[index*3+1] === 0 && brush[index*3+2] === 0) {
        const factor = 1;
        for (let dx = -factor; dx <= factor; dx++) {
          for (let dz = -factor; dz <= factor; dz++) {
            for (let dy = -factor; dy <= factor; dy++) {
              const ax = x + dx;
              const ay = y + dy;
              const az = z + dz;
              if (ax >= 0 && ax < PARCEL_SIZE && ay >= 0 && ay < PARCEL_SIZE && az >= 0 && az < PARCEL_SIZE) {
                const index2 = ax + ay*size*size + az*size;
                const xi = index2*3;
                const yi = index2*3+1;
                const zi = index2*3+2;
                // if (brush[xi] === 0 && brush[yi] === 0 && brush[zi] === 0) {
                  brush[xi] = currentColor.r*255;
                  brush[yi] = currentColor.g*255;
                  brush[zi] = currentColor.b*255;
                // }
              }
            }
          }
        }
      /* } else {
        brush[index*3] = currentColor.r*255;
        brush[index*3+1] = currentColor.g*255;
        brush[index*3+2] = currentColor.b*255;
      } */
    }
    const arrayBuffer = new ArrayBuffer(300*1024);
    worker.request({
      method: 'march',
      dims,
      potential,
      brush,
      shift,
      scale,
      arrayBuffer
    }, [arrayBuffer]).then(res => {
      geometry.setAttribute('position', new THREE.BufferAttribute(res.positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(res.colors, 3));
      geometry.removeAttribute('normal');
      geometry.computeVertexNormals();
      // geometry.setIndex(new THREE.BufferAttribute(res.faces, 1));

      /* if (potential.every(n => n <= 0)) {
        const {x, z} = mesh;
        fetch('https://djj7y2i5p8.execute-api.us-west-1.amazonaws.com/default/Webaverse', {
          method: 'POST',
          body: JSON.stringify({
            addr: window.web3.eth.defaultAccount,
            x,
            y: z,
          }),
        })
          .then(res => res.json())
          .then(o => {
            const {v, r, s} = o;
            const addr = window.web3.eth.defaultAccount;
            console.log('mintTokenFromSignature', {addr, x, z, v, r, s});
            return user.execute({
              method: 'mintTokenFromSignature',
              data: {
                addr,
                x,
                y: z,
                v,
                r,
                s,
              },
            });
          })
          .then(() => {
            console.log('mined', {x, z});

            for (;;) {
              const index = sceneMeshes.findIndex(sceneMesh => sceneMesh.token.coords.some(coord => coord[0] === x && coord[1] === z));
              if (index !== -1) {
                const sceneMesh = sceneMeshes[index];
                sceneMesh.destroy();
                scene.remove(sceneMesh);
                sceneMeshes.splice(index, 1);
              } else {
                break;
              }
            }

            const sceneMesh = _makeSceneObjectMesh();
            sceneMesh.token = {
              id: 0,
              coords: [[x, z]],
              apps: [],
              owner: _getUserAddress(),
            };
            scene.add(sceneMesh);
            sceneMeshes.push(sceneMesh);

            selectedSceneToken = null;

            lastSceneCoords[0] = NaN;
            lastSceneCoords[1] = NaN;
          });
      } */
      mesh.visible = true;
    });
  };
  mesh.destroy = () => {
    geometry.dispose();
    material.dispose();
  };
  let colliding = false;
  mesh.update = () => {
    if (!colliding && geometry.attributes.position) {
      colliding = true;

      const controllerMesh = controllerMeshes[1]; // XXX make this work for all controllers
      worker.request({
        method: 'collide',
        positions: geometry.attributes.position.array,
        indices: geometry.index.array,
        origin: controllerMesh.ray.origin.toArray(new Float32Array(3)),
        direction: controllerMesh.ray.direction.toArray(new Float32Array(3)),
      })
        .then(collision => {
          material.uniforms.uSelect.value.fromArray(collision);
        })
        .catch(err => {
          console.warn(err.stack);
        })
        .finally(() => {
          colliding = false;
        });
    }
  };
  mesh.intersect = ray => {
    if (isFinite(material.uniforms.uSelect.value.x)) {
      const intersectionPoint = material.uniforms.uSelect.value.clone();
      const distance = ray.origin.distanceTo(intersectionPoint);
      return {
        type: 'mine',
        mesh,
        intersectionPoint,
        distance,
      };
    } else {
      return null;
    }
  };

  const arrayBuffer = new ArrayBuffer(300*1024);
  worker.request({
    method: 'march',
    dims,
    potential,
    shift,
    scale,
    arrayBuffer
  }).then(res => {
    geometry.setAttribute('position', new THREE.BufferAttribute(res.positions, 3));
    // geometry.setIndex(new THREE.BufferAttribute(res.faces, 1));
    mesh.visible = true;
  });

  return mesh;
};
const miningMesh = _makeMiningMesh(0, 0);
scene.add(miningMesh);

const localRaycaster = new THREE.Raycaster();
window.addEventListener('mousemove', e => {
  const mouse = new THREE.Vector2(( ( event.clientX ) / window.innerWidth ) * 2 - 1, - ( ( event.clientY ) / window.innerHeight ) * 2 + 1);
  localRaycaster.setFromCamera(mouse, camera);
  const targetPosition = localRaycaster.ray.origin.clone()
    .add(new THREE.Vector3(0, 0, -1).applyQuaternion(new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), localRaycaster.ray.direction)));
  pointerMesh.material.uniforms.targetPos.value.set(
    Math.floor((0.5+targetPosition.x)*10),
    Math.floor((0.5+targetPosition.y)*10),
    Math.floor((0.5+targetPosition.z)*10)
  );
});
window.addEventListener('mousedown', e => {
  const v = pointerMesh.material.uniforms.targetPos.value;
  const x = v.x+1;
  const y = v.y+1;
  const z = v.z+1;
  miningMesh.paint(x, y, z);
});

function animate() {
  orbitControls.update();

  renderer.render(scene, camera);
}
renderer.setAnimationLoop(animate);
</script>
  </body>
</html>